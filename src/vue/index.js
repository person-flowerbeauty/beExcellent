/**
 * \有转译的作用，在正则中.本来代表匹配所有，但是如果使\.就相当于只能匹配单纯的.
 * 而正则有两种表达方式，一是直接声明式，直接写let a = /\./就可以表达。
 * 二是通过构造函数生成，new RegExp(ex);这里ex可以为正则，可以为字符串，也可以是代表字符串的变量
 * 所以第二种方式就产生了可以通过字符串生成正则的形式，但是在字符串中\也有转译的意思，即在字符串中写了'\.'相当于已经给.转译
 * 但是，在生成正则后就成为了/./这样，.还是代表匹配所有的意思，即未转译。所以在字符串中使用'\\.'生成正则变为/\./代表单纯匹配一个.的意思
 */
const regStr = '[\\-\\.]'

/**
 * ?:在正则中的作用就是分组但是不捕获，这里不捕获是匹配结果不返回当前分组的捕获，指的是不捕获下来供正则其他表达式使用。
 * 比如下面例子中的\1，一般\1表示捕获到的第一个分组项，但是使用(?:)后\1并不能代表ab了，所以regStr1不能匹配到abcdab
 * 另一个作用是，如果分组较多，而不想捕获一些无用的分组，就可以使用?:跳过这些无用的捕获
 */
const regStr1 = '(?:ab)cd\\1';
const regStr2 = '(ab)cd\\1';
console.log('?:', 'abcdab'.match(regStr1), 'abcdab'.match(regStr2));

console.log(/\:/.test(':')); 

// umd模式会涉及到的一个写法
function test (a, b = () => {console.log('aaa')}) {
    window ? (a = 1, b(a)) : a = 2;
    console.log(a);
}
test()

// new Function让字符串作为函数执行
/**
 * 最后一个参数是函数体，前面的参数作为新函数的形参
 * 返回一个新函数
 */
const strFunc = new Function('a', 'b', `return b === false`);
console.log(strFunc(0, false));