## for in 和 Object.keys的区别
1. for..in是javascript中最常见的迭代语句，常常用来枚举对象的属性。某些情况下，可能按照随机顺序遍历数组元素。
2. 而Object构造器有一个实例属性keys，则可以返回以对象的属性为元素的数组。数组中属性名的顺序跟使用for..in遍历返回的顺序是一样的。不会遍历对象原型链上的属性以及Symbol属性
3. for..in循环会枚举对象原型链上的可枚举属性，而object.keys不会

## 请说出目前主流的js模块化实现的技术有哪些?他们的区别在哪儿?
1. CommonJS：NodeJS是CommonJS规范的主要实践者，有四个重要的环境变量为模块化的实现提供支持：module、exports、require、global。实际上使用时，用module.exports定义当前模块对外输出的接口，用require加载模块
   - 一个文件就是一个模块，拥有单独的作用域
   - 普通方式定义的变量、函数、对象都属于该模块内容
   - 通过require来加载模块
   - 通过exports和module.exports来暴露块中的内容
   - 模块可以多次加载，但只会在第一次加载时运行时结果就会被缓存，以后再加载的时候就直接读取缓存结果
   - 模块加载顺序，按照代码出现的顺序同步加载
2. ES6模块化：主要为浏览器和服务器通用的模块解决方案。其模块功能主要由两个命令构成：export和import。export命令用于规定模块的对外接口，import命令用于输入其他模块提供的功能
   - ES6的模块不是对象，import命令会被JS引擎静态分析，在编译时就引入模块代码，而不是在代码运行时加载，所以无法实现条件加载。也正因此，是的静态分析成为可能
3. AMD：AMD规范采用异步方式加载模块，模块的加载不影响它后面语句的运行。所有依赖这个模块的语句，都定义在一个回调函数中，等到加载完成之后，这个回调函数才会运行
4. CMD：AMD推崇依赖前置，提前执行，CMD推崇依赖就近，延迟执行
5. UMD：一种整合CommonJS和AMD规范的方法，希望能解决跨平台模块方案
   - UMD先判断是否支持NodeJS的模块(exports)是否存在，存在就是用nodejs模块模式，
   - 在判断是否支持AMD(define是否存在)，存在则使用AMD方式加载

## 简单介绍使用图片base64编码的优点和缺点
base64 编码是一种图片处理格式，通过特定的算法将图片编码成一长串字符串，在页面上显示的时候，可以用该字符串来代替图片的url 属性。
   - 优点：减少依赖图片的http请求。
   - 缺点：
        1. 根据 base64 的编码原理，编码后的大小会比原文件大小大 1/3，如果把大图片编码到html/css 中，不仅会造成文件体积的增加，影响文件的加载速度，还会增加浏览器对 html 或 css 文件解析渲染的时间。
        2. 使用 base64 无法直接缓存，要缓存只能缓存包含 base64 的文件，比如 HTML 或者 CSS，这相比域直接缓存图片的效果要差很多。
        3. 兼容性的问题，ie8 以前的浏览器不支持。

## 谈谈你对ajax的理解?
ajax是一种异步通信的方法，通过直接由 js 脚本向服务器发起 http 通信，然后根据服务器返回的数据，更新网页的相应部分，而不用刷新整个页面的一种方法。
   - 首先是创建一个 XMLHttpRequest 对象
   - 在这个对象上使用 open 方法创建一个http 请求，open 方法所需要的参数是请求的方法、请求的地址、是否异步和用户的认证信息
   - 我们可以通过setRequestHeader 方法来为请求添加头信息
   - 我们还可以为这个对象添加一个状态监听函数。一个 XMLHttpRequest 对象一共有 5 个状态，当它的状态变化时会触发onreadystatechange 事件，我们可以通过设置监听函数，来处理请求成功后的结果
   - 当对象的 readyState 变为 4 的时候，代表服务器返回的数据接收完成
   - 状态是 2xx 或者 304 的话则代表返回正常
   - 我们就可以通过response 中的数据来对页面进行更新了
   - 我们调用send 方法来向服务器发起请求，可以传入参数作为发送的数据体

## Object.is()与原来的比较操作符 "===" 、"==" 的区别?
- 使用双等号进行相等判断时，如果两边的类型不一致，则会进行强制类型转化后再进行比较
- 使用三等号进行相等判断时，如果两边的类型不一致时，不会做强制类型准换，直接返回 false
- 使用 Object.is 来进行相等判断时，一般情况下和三等号的判断相同，它处理了一些特殊的情况，比如 -0 和 +0 不再相等，两个 NaN 认定为是相等的。

## 三种事件模型是什么?
事件是用户操作网页时发生的交互动作或者网页本身的一些操作，现代浏览器一共有三种事件模型。
- DOM0 级事件模型 第一种事件模型是最早的 DOM0 级模型，这种模型不会传播，所以没有事件流的概念，但是现在有的浏览器支持以冒泡的方式实现，它可以在网页中直接定义监听函数，也可以通过 js 属性来指定监听函数。这种方式是所有浏览器都兼容的。
- IE事件模型 在该事件模型中，一次事件共有两个过程，事件处理阶段，和事件冒泡阶段。事件处理阶段会首先执行目标元素绑定的监听事件。然后是事件冒泡阶段，冒泡指的是事件从目标元素冒泡到 document，依次检查经过的节点是否绑定了事件监听函数，果有则执行。这种模型通过 attachEvent 来添加监听函数，可以添加多个监听函数，会按顺序依次执行。
- DOM2 级事件模型 在该事件模型中，一次事件共有三个过程，第一个过程是事件捕获阶段。捕获指的是事件 document 一直向下传播到目标元素，依次检查经过的节点是否绑定了事件监听函数，如果有则执行。后面两个阶段和 IE 事件模型的两个阶段相同。这种事件模型，事件绑定的函数是 addEventListener，其中第三个参数可以指定事件是否在捕获阶段执行。

## DOCTYPE 的作用是什么?
- IE5.5 引入了文档模式的概念，而这个概念是通过使用文档类型（DOCTYPE）切换实现的。
- <!DOCTYPE> 声明一般位于文档的第一行，它的作用主要是告诉浏览器以什么样的模式来解析文档。一般指定了之后会以标准模式来进行文档解析，否则就以兼容模式进行解析。在标准模式下，浏览器的解析规则都是按照最新的标准进行解析的。而在兼容模式下，浏览器会以向后兼容的方式来模拟老式浏览器的行为，以保证一些老的网站的正确访问。
- 在 html5 之后不再需要指定 DTD 文档，因为 html5 以前的 html 文档都是基于SGML 的，所以需要通过指定 DTD 来定义文档中允许的属性以及一些规则。而 html5 不再基于 SGML 了，所以不再需要使用 DTD。

## 哪些操作会造成内存泄漏?
- 第一种情况是我们由于使用未声明的变量，而意外的创建了一个全局变量，而使这个变量一直留在内存中无法被回收。
- 第二种情况是我们设置了 setInterval 定时器，而忘记取消它，如果循环函数有对外部变量的引用的话，那么这个变量会被一直留在内存中，而无法被回收。
- 第三种情况是我们获取一个 DOM 元素的引用，而后面这个元素被删除，由于我们一直保留了对这个元素的引用，所以它也无法被回收。
- 第四种情况是不合理的使用闭包，从而导致某些变量一直被留在内存当中。

## 如何加快页面渲染速度，都有哪些方式？
1. 静态资源的优化：主要是减少静态资源的加载时间，主要包括html、js、css和图片
   - 减少http请求次数：合并js、css、制作雪碧图以及使用http缓存（modify、etag）
   - 减少资源的大小：压缩图片、压缩文件、小图使用base64编码
   - 异步加载组件和懒加载
   - cdn加速和缓存：客户端可以通过最佳的网络链路加载静态资源，提供访问速度和成功率。
2. 接口访问优化
   - http持久链接
   - 数据接口缓存到localStorage，减少请求
   - 后端优化和并请求
3. 页面渲染速度的优化
   - 由于浏览器的js引擎线程和GUI渲染线程是互斥的，所以在执行js的时候会阻塞它的渲染，所以一般会将css放到顶部，优先渲染，js在底部
   - 减少dom操作。使用虚拟dom渲染方案，做到最小化操纵真实的dom
   - 事件代理：利用事件冒泡原理，把函数注册到父级元素上
   - 减少页面的重绘和回流

## 你所理解,同步和异步的区别是什么?(js部分)
   - 同步指的是当一个进程在执行某个请求的时候，如果这个请求需要等待一段时间才能返回，那么这个进程会一直等待下去，知道消息返回为止，再继续向下执行。
   - 异步指的是当一个进程在执行某个请求是，如果这个请求需要等待一段时间才能返回，这个时候进程会继续往下执行，不会阻塞等待消息的返回，当消息返回时系统再通知进程进行处理。

## 什么是 Polyfill ?(js部分)
   - Polyfill指的是用来实现浏览器并不支持的原生API的代码。
   - 比如querySelectorAll是1很多现代浏览器都支持的原生Web API，但是有些古老的浏览器并不支持，那么假设有人写了一段代码来实现这个功能是这些浏览器也支持了这个功能，那么这就可以成为一个Polyfill
   - 一个shim是一个库，有自己的API，而不是单纯实现原生不支持的API

## javascript 代码中的"use strict"是什么意思?为什么使用它?
  1. use strict是一种ECMAscript5添加的运行模式，这种模式是的js在更严格的条件下运行，设立严格模式的目的主要是为了：
      - 消除js语法中一些不合理、不严谨只处，减少一些怪异行为
      - 消除代码运行的一些不安全之处，保证代码运行的安全。
      - 提高编译器效率，增加运行速度。
      - 为未来新版本的js做好铺垫。
  2. 这种模式对js使用添加了一些限制。比如说this指向全局对象，还有禁止使用with语句等。
   
## componentWillReceiveProps的触发条件是什么？
1. componentWillReceiveProps通常被认为是propsWillChange，我们确实也通过他来判断props change。但实际上，它在每次渲染时都会调用，无论props变化与否。比如父组件重新渲染，父组件的render也会导致子组件跟着渲染。
2. 也就是说componentWillReceiveProps的调用时机是：引发当前组件&&(context发生变化||父组件render结果发生变化，即当前组件需要render)

## React事件绑定原理是什么？
1. React并不是将click事件绑在该div的真实DOM，而是在document处监听所有支持的事件，当事件发生并冒泡至document处时，React将事件内容封装并交由真正的处理函数运行。这样的方式不仅减少了内存消耗，还能在组件挂在销毁时统一订阅和移除事件
2. 另外冒泡到document上的事件也不是原生浏览器事件，而是React自己实现的合成事件。因此我们如果不想要事件冒泡的话，调用event.stopPropagation是无效的，而应该调用event.preventDefault进行阻止

## React 高阶组件、Render props和hooks有什么区别,为什么不断迭代?
1. 这三者是目前react解决代码复用的主要方式。
2. 高阶组件(HOC)是React中用于复用组件逻辑的一种高级技巧。HOC自身不是React API中的一部分，它是一种基于React的组合特性而形成的设计模式。具体而言，高阶组件是参数为组件，返回值为新组件的函数
   - 优点：逻辑复用，不影响被包裹组件的内部逻辑
   - 缺点：hoc传递给被包裹组件的props容易和被包裹后的组件重名，会被覆盖掉
3. render props是指一种在React组件之间使用一个值为函数的prop共享代码的简单技术，更具体的说，render prop 是一个用于告知组件需要渲染什么内容的函数prop
   - 优势：数据共享、代码复用、将组件内的state作为props传递给调用者，将渲染逻辑交给调用者
   - 劣势：无法再return语句外访问数据、嵌套写法不够优雅 
4. 通常，render props和高阶组件只渲染一个子节点。让HOOKS来服务这个场景更加简单。这两种模式仍有用武之地，但是在大部分场景下，HOOK足够了，并且能够帮助减少嵌套。
5. react hooks 是 React 16.8 的新增特性。 它可以让我们在函数组件中使用 state 、生命周期以及其他 react特性，而不仅限于 class 组件。react hooks 的出现，标示着 react中不会在存在无状态组件了，只有类组件和函数组件

## javascript 创建对象的几种方式?
1. 我们一般使用字面量的形式创建对象。但是这中创建方式对于创建大量相似对象的时候，会产生大量的重复代码，但js和一般的面向对象的语言不同，在ES6之前它没有类的概念。
2. 我们可以使用函数来进行模拟，从而产生出可复用的对象创建方式有以下几种：
   - 工厂模式：工厂模式的主要工作原理是用函数来封装创建对象的细节，从而通过调用函数来达到复用的目的。但是它有一个很大的问题就是创建出来的对象无法和某个类型联系起来。它只是简单的封装了复用代码，而没有建立起对象和类型间的关系。
   - 构造函数模式：js中每一个函数都可以作为构造函数，只要一个函数是通过new来调用的，那么我们就可以把它成为构造函数，执行构造函数首先会创建一个对象，然后将对象的原型指向构造函数的prototype属性，然后将执行上下文中的this指向这个对象，最后再执行整个函数，如果返回值不是对象则返回新建的对象。因为this的值指向了新建对象，因此我们可以使用this给对象赋值。构造函数模式相对于工厂模式的优点是，所创建的对象和构造函数建立了联系，因此我们可以通过原型来识别对象模型。但是构造函数存在一个缺点就是，造成了不必要的函数对象创建，这种情况存在于如果属性值是一个函数的话，每次我们都会创建一个新的函数对象，浪费了内存空间。
   - 原型模式：每一个函数都有一个prototype属性，这个属性是一个对象，它包含了通过构造函数创建的所有实例都能共享的属性和方法。因此我们可以使用原型对象来添加公用属性和方法，从而实现代码的复用。这种方式相对于构造函数模式来说，解决了函数对象的复用问题，但也存在一些问题，没有办法通过传入参数来初始化值，如果存在引用类型的值时，所有实例共享这一个对象，会相互影响。
   - 组合使用构造函数和原型模式：这是创建自定义类型的最常见方式，因为构造函数模式和原型模式分开使用都存在一些问题，因此我们可以使用两种组合的模式，通过构造函数来初始化对象属性，通过原型对象来实现函数方法的复用。唯一缺点，就是封装行不是很好，因为prototype要写在外面。
   - 动态原型模式：这一种模式将原型方法赋值的创建过程移动到了构造函数的内部，通过对属性是否存在的判断，可以实现仅在第一次调用函数时对原型对象赋值一次的效果。这一种方式很好地对上面的混合模式进行了封装。
   - 寄生构造函数模式：这一种模式和工厂模式的实现基本相同，它主要是基于一个已有的类型，在实例化时对实例化的对象进行扩展。这样既不用修改原来的构造函数，也达到了扩展对象的目的。它的一个缺点和工厂模式一样，无法实现对象的识别。

## 如何判断一个对象是否属于某个类?
1. 第一种方式是使用 instanceof 运算符来判断构造函数的 prototype 属性是否出现在对象的原型链中的任何位置
2. 第二种方式可以通过对象的 constructor 属性来判断，对象的 constructor 属性指向该对象的构造函数，但是这种方式不是很安全，因为 constructor 属性可以被改写
3. 第三种方式，如果需要判断的是某个内置的引用类型的话，可以使用Object.prototype.toString.call() 方法来打印对象的[[Class]] 属性来进行判断

## 说一下你所理解的渲染原理?
1. 首先解析收到的文档，根据文档定义构建一棵DOM树，DOM树是由DOM元素及属性节点组成。
2. 对css进行解析，生成CSSOM规则树。
3. 根据DOM树和CSSOM规则树构建渲染树，渲染树的节点被称为渲染对象，渲染对象是一个包含有颜色和大小等属性的矩形，渲染对象和DOM元素相对应，但这种关系不是一对一的，不可见的DOM元素不会被插入渲染树。还有一些DOM元素对应几个可见对象，他们一般具有复杂结构的元素，无法用一个矩形来形容。
4. 当渲染对象被创建并添加到树中，它们并没有位置和大小，所以当浏览器生成渲染树以后，就会根据渲染树来进行布局，也可叫回流。这阶段浏览器要做的事情是要弄清楚各个节点在页面中的确切位置和大小。通常这一行为也被称为“自动重排”。
5. 布局阶段结束后是绘制阶段，遍历渲染树并调用渲染对象的 paint 方法将它们的内容显示在屏幕上，绘制使用 UI 基础组件。值得注意的是，这个过程是逐步完成的，为了更好的用户体验，渲染引擎将会尽可能早的将内容呈现到屏幕上，并不会等到所有的 html都解析完成之后再去构建和布局 render 树。它是解析完一部分内容就显示一部分内容，同时，可能还在通过网络下载其余内容。

## 扫描二维码登录网页是什么原理，前后两个事件是如何联系的?
1. 浏览器获得一个临时id，通过长连接等待客户端扫描带有此id的二维码后，从长连接中获得客户端上报给server的账号信息进行展示。并在客户端点击确认后，获得服务端授信的令牌，进行随后的信息交互过程。在超时、网络断开、其他设备上登陆只有，此前获得的令牌或丢失或失效，对授权过程形成有效的防护
2. 当客户端点击确认授权登陆后，服务器生成一个权限令牌给网页，网页之后使用这个令牌进行信息的交互过程。

## margin和padding分别适合什么场景使用?
margin 是用来隔开元素与元素的间距；padding 是用来隔开元素与内容的间隔。 margin 用于布局分开元素使元素与元素互不相干。 padding 用于元素与内容之间的间隔，让内容（文字）与（包裹）元素之间有一段距离。
1. margin:
   - 需要在 border 外侧添加空白时。
   - 空白处不需要背景（色）时。
   - 上下相连的两个盒子之间的空白，需要相互抵消时。如 15px+20px 的 margin，将得到 20px的空白。
2. padding:
   - 需要在 border 内侧添加空白时
   - 空白处需要背景（色）时。
   - 上下相连的两个盒子之间的空白，希望等于两者之和时。如 15px+20px 的 padding，将得到35px 的空白.

## CSS多列等高如何实现?
1. 利用 padding-bottom|margin-bottom 正负值相抵，不会影响页面布局的特点。设置父容器设置超出隐藏（overflow:hidden），这样父容器的高度就还是它里面的列没有设定 padding-bottom 时的高度，当它里面的任一列高度增加了，则父容器的高度被撑到里面最高那列的高度，其他比这列矮的列会用它们的 padding-bottom补偿这部分高度差。
2. 利用 table-cell 所有单元格高度都相等的特性，来实现多列等高。
3. 利用 flex 布局中项目 align-items 属性默认为 stretch，如果项目未设置高度或设为 auto，将占满整个容器的高度的特性，来实现多列等高。

## 什么是DOM和BOM?
1. DOM 指的是文档对象模型，它指的是把文档当做一个对象来对待，这个对象主要定义了处理网页内容的方法和接口。
2. BOM 指的是浏览器对象模型，它指的是把浏览器当做一个对象来对待，这个对象主要定义了与浏览器进行交互的法和接口。
3. BOM 的核心是 window，而 window 对象具有双重角色，它既是通过 js 访问浏览器窗口的一个接口，又是一个 Global（全局）对象。这意味着在网页中定义的任何对象，变量和函数，都作为全局对象的一个属性或者方法存在。window 对象含有 location 对象、navigator 对象、screen 对象等子对象，并且 DOM 的最根本的对象 document 对象也是 BOM 的 window 对象的子对象。

