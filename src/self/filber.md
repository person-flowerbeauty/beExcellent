## 20200426晚公开课。filber基础
- filber是把一个大任务分成若干小任务，在浏览器空闲的时候来执行
- 个人理解：之前react渲染前要进行DOM diff，虚拟DOM就会作为一个最小执行单元，进行深度优先遍历的比对，然后再进行更新，这个阶段是一直占用浏览器的，无法中断，如果项目比较深比则会造成浏览器渲染的卡顿。react的更新机制与vue的不一样，vue是小组件更新，改动只是小范围更新，可以当作速度极快的更新。而react的更新，就是无论哪里更新了都会从顶层进行一个深度的diff，然后再更新。而react16通过filber实现，就是先把调和（reconciliation: diff阶段）和 更新（commit： 更新）阶段分开，在diff阶段可以被中断，而更新阶段不中断。是通过把之前的虚拟dom转成单链表数据结构的filber树，这样浏览器空闲的时候能在中断位置继续进行比对，不影响浏览器渲染。
## 浏览器的渲染机制
浏览器内核是支持浏览器运行的最核心程序：渲染引擎、js引擎。
- 请求后服务端返回HTML格式的字符串。因为只有HTML格式的字符串能被正确解析。
- 渲染过程：
    - 1、解析：把html结构的字符串解析（通过html parser）成DOM树形结。把css解析成CSSSOM树，这个过程比DOM复杂，因为节点可以有自己的属性也可以继承属性，所以需要递归生成，才能匹配HTML元素，相当复杂和消耗性能，所以DOM树尽量小，css尽量使用id和class，不要过渡层。等待js脚本文件加载。
    - 2、解析后引擎会通过DOM Tree和 CSS Rule Tree来构造Rendering Tree（只展示需要展示的节点，并把css匹配到每个元素上，然后计算每个Frame的位置又叫回流、重绘）。
    - 3、调用操作系统的Native GUI的API进行绘制
- 渲染过程中碰到<script></script>标签会停止渲染，渲染线程给js线程让路，等待js引擎执行完毕再从中断的地方恢复DOM构建。所以如果想让首屏渲染加快，就不应该在首屏加载js，放在body底部，或者通过标签的defer和async属性控制。另一方面，本来CSSOM和DOM是互不干涉可以同时进行构建的，但是如果这时js引擎中断DOM构建，那么会先等待CSSOM树构建完成再执行js最后在回复DOM构建，因为js可以更改样式，而不完整的CSSOM是无法使用的，所以执行js前需要拿到完整的CSSOM
- async和derfer的区别：https://juejin.im/post/5ca0c0abe51d4553a942c17d
## 浏览器的进程与线程
- 浏览器是多进程的，就是可以开多个窗口.内核控制下多个线程保持同步。
- GUI渲染线程，js引擎线程（单线程）、定时器触发线程（定时计数器的计数和触发）、事件触发线程（定时任务、请求、交互被触发时，该线程会把任务添加到等待队列的尾部等待js引擎的处理）、异步http请求线程
- GUI渲染线程和js引擎线程是互斥的，因为js操作DOM时如果重新渲染了会导致操作的DOM数据不准确。
## 公开课内容
- 大部分浏览器都是在频率60Hz也就是对应着16.6ms会刷新一帧。所以，动画或者页面渲染也需要保持一致保证页面流畅。
- 浏览器运行优先级：事件 -> 定时器 -> js开始帧 => rAF -> 重绘或回流的渲染 -> 空闲。每一帧都经过这些操作，任何操作都可能造成卡帧。
- rAF：requestAnimationFrame。// raf.html
- window.requestIdleCallback(callback, {timeout: 1000}).浏览器每一帧执行后，如果有空闲时间就会执行用户代码，没有则不执行，一旦执行就会执行完不会中断，如果timeout到时间了无论是否有剩余时间都会立即执行。callback接受一个默认参数，deadline：deadline.timeRemaining()代表当前帧剩余时间，deadline.didTimeout代表任务超时。 // idle.html
- 单链表：链式存取的数据结构。自身数据 + 指向下一个节点的指针。 // 链.js
- filber：最小的执行单元。并不舍弃虚拟DOM，只是把原虚拟DOM变成filber树，在深度优先遍历时，可以中断，并且可以恢复。filber单元拥有三个特殊属性：return指向父级，sibling指向下一个兄弟，child指向第一个儿子。深度优先遍历时，先逐层向下遍历儿子，某一单元没有儿子时这个单元先执行完成，找这个单元的下一个兄弟执行上述操作，当找不到下一个兄弟时，使用return返回父级，并找父级的下一个兄弟开始执行。  // filber.js


## 虚拟DOM
- jsx在babel编译时就会把jsx编译成js
- React.createElement。
- 后续遍历
- 根filber。原生节点、函数组件、文本节点
- 每个filber都有一个tag标识标识此元素类型。根filber的stateNode标识挂在的真是元素。props的children存放虚拟DOM后续会转换程filber。从跟阶段开始调度和渲染